# -*- coding: utf-8 -*-
"""MineSweeper.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1z-YjcbLR4zwIOBWP9ATY1tL65gNX3S3m
"""

#Console-based Minesweeper-game
#The game generates a grid, places bombs and the
#player is able to reveal the fields

import numpy as np

def Gridgeneration():
      """
      Generates a 12x12 grid with randomly placed bombs.
      Also creates a reveal matrix to track uncovered fields.
      Bomb counts are calculated for each non-bomb cell.
      The outer border is marked to prevent index errors.
      Returns the grid, reveal state, and display grid.
      """

      #both is an 12x12 array due to added the border
      Grid = np.array([["0"]*12]*12)
      FieldRevealed = np.array([[True]*12]*12)

      #generates a random position for every bomb in the grid
      for i in range(15):
         z = np.random.randint(1,11)
         s = np.random.randint(1,11)
         while Grid[z][s] == "B":
             z = np.random.randint(1,11)
             s = np.random.randint(1,11)
         Grid[z][s] = "B"

      #Adds a border to prevent index errors during neighbor checks
      for r in range(11):
        Grid[0][r] = "X"
        Grid[11][r] = "X"
        Grid[r][0] = "X"
        Grid[r][11] = "X"

      #counts the nearby bombs for every field except the bombs and the border
      counter = np.array([[0]*12]*12)
      for k in range(1,11):
        for l in range(1,11):
          if Grid[k][l] == "0":
            FieldRevealed[k][l] = False
            if Grid[k-1][l-1] == "B":
              counter[k][l] += 1
            if Grid[k-1][l] == "B":
              counter[k][l] += 1
            if Grid[k-1][l+1] == "B":
              counter[k][l] += 1
            if Grid[k][l-1] == "B":
              counter[k][l] += 1
            if Grid[k][l+1] == "B":
              counter[k][l] += 1
            if Grid[k+1][l-1] == "B":
              counter[k][l] += 1
            if Grid[k+1][l] == "B":
              counter[k][l] += 1
            if Grid[k+1][l+1] == "B":
              counter[k][l] += 1
          if Grid[k][l] == "0" and counter[k][l] > 0:
            Grid[k][l] = counter[k][l]

      #generates a separate grid which getting shown, to avoid errors
      GridShow = np.array([[" "]*12]*12)
      for r in range(11):
        GridShow[0][r] = "X"
        GridShow[11][r] = "X"
        GridShow[r][0] = "X"
        GridShow[r][11] = "X"
      return Grid, FieldRevealed, GridShow

def NearbyCheck(row, column, Grid, FieldRevealed):
      """
      Recursively reveals empty (0) fields in a '+'-shaped pattern.
      Also reveals nearby numbered fields that border empty fields.
      Avoids revealing bombs or border cells.
      Used after the player clicks on an empty cell.
      """

      #checking every direction
      if Grid[row-1][column] == "0" and not FieldRevealed[row-1][column]:
          FieldRevealed[row-1][column] = True
          #using recursion to check the fields beyond the specified
          NearbyCheck(row-1, column, Grid, FieldRevealed)
      #checking for bombs or border to stop the recursion
      elif Grid[row-1][column] != "B" and Grid[row-1][column] != "X":
          FieldRevealed[row-1][column] = True
      if Grid[row+1][column] == "0" and not FieldRevealed[row+1][column]:
          FieldRevealed[row+1][column] = True
          NearbyCheck(row+1, column, Grid, FieldRevealed)
      elif Grid[row+1][column] != "B" and Grid[row+1][column] != "X":
          FieldRevealed[row+1][column] = True
      if Grid[row][column-1] == "0" and not FieldRevealed[row][column-1]:
          FieldRevealed[row][column-1] = True
          NearbyCheck(row, column-1, Grid, FieldRevealed)
      elif Grid[row][column-1] != "B" and Grid[row][column-1] != "X":
          FieldRevealed[row][column-1] = True
      if Grid[row][column+1] == "0" and not FieldRevealed[row][column+1]:
          FieldRevealed[row][column+1] = True
          NearbyCheck(row, column+1, Grid, FieldRevealed)
      elif Grid[row][column+1] != "B" and Grid[row][column+1] != "X":
          FieldRevealed[row][column+1] = True
      #checking and revealing the missing numbers at the corners
      if Grid[row-1][column-1] != "B" and Grid[row-1][column-1] != "X" and Grid[row-1][column-1] != "0":
        FieldRevealed[row-1][column-1] = True
      if Grid[row-1][column+1] != "B" and Grid[row-1][column+1] != "X" and Grid[row-1][column+1] != "0":
        FieldRevealed[row-1][column+1] = True
      if Grid[row+1][column-1] != "B" and Grid[row+1][column-1] != "X" and Grid[row+1][column-1] != "0":
        FieldRevealed[row+1][column-1] = True
      if Grid[row+1][column+1] != "B" and Grid[row+1][column+1] != "X" and Grid[row+1][column+1] != "0":
        FieldRevealed[row+1][column+1] = True

def GameLogic(Grid, FieldRevealed, GridShow):
      """
      Getting and checking input for errors.
      Reveals cells based on input.
      Triggers recursive reveal for empty cells.
      Ends the game on bomb hit or if all non-bomb fields are revealed.
      """
      #revealing the bombs to check the win
      for d in range(1,11):
              for u in range(1,11):
                if Grid[d][u] == "B":
                  FieldRevealed[d][u] = True

      #border and bombs are revealed but not shown to get an end
      while FieldRevealed.all() != True:
              #getting and checking the input to get it correctly
              row = int(input("row:1-10 "))
              if row not in range(1,11):
                print("Error! Take a valid number!")
                row = int(input("row:1-10 "))
              column = int(input("column:1-10 "))
              if column not in range(1,11):
                print("Error! Take a valid number!")
                column = int(input("column:1-10 "))

              #by losing it reveals the whole grid to look where are the bombs
              if Grid[row][column] == "B":
                  print(Grid)
                  print("BOOM")
                  print("You lost!")
                  #stops the round
                  break


              elif Grid[row][column] == "0":
                    #the specified field gets revealed
                    FieldRevealed[row][column] = True
                    #because of hitting a 0 the check for nearby 0s starts
                    NearbyCheck(row,column, Grid, FieldRevealed)
                    #its responsible for showing every revealed field except
                    #the bombs
                    for m in range(1,11):
                      for n in range(1,11):
                          if FieldRevealed[m][n] == True and Grid[m][n] != "B":
                              GridShow[m][n] = Grid[m][n]
                    if FieldRevealed.all():
                        #if the player won, it stops the game
                        break

              #revealing the numbers if the player didn't hit a 0 or a bomb
              elif Grid[row][column] != "B" and Grid[row][column] != "0":
                    FieldRevealed[row][column] = True
                    for m in range(1,11):
                        for n in range(1,11):
                            if FieldRevealed[m][n] == True and Grid[m][n] != "B":
                                GridShow[m][n] = Grid[m][n]
                    if FieldRevealed.all():
                          print(Grid)
                          print("You won, every fields, except for the bombs, are revealed!")
                          break
              #shows the live-grid after every input
              print(GridShow)



Grid, FieldRevealed, GridShow = Gridgeneration()
GameLogic(Grid, FieldRevealed, GridShow)